/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, ApiContext } from "./apiContext";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";

export type GetAnnouncementsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetAnnouncementsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetAnnouncementsVariables = {
  queryParams?: GetAnnouncementsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetAnnouncements = (
  variables: GetAnnouncementsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.AnnouncementListResponse,
    GetAnnouncementsError,
    undefined,
    {},
    GetAnnouncementsQueryParams,
    {}
  >({ url: "/announcements", method: "get", ...variables, signal });

export const useGetAnnouncements = <TData = Schemas.AnnouncementListResponse>(
  variables: GetAnnouncementsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AnnouncementListResponse,
      GetAnnouncementsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.AnnouncementListResponse,
    GetAnnouncementsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/announcements",
      operationId: "getAnnouncements",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAnnouncements({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostAnnouncementsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostAnnouncementsVariables = {
  body: Schemas.AnnouncementRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostAnnouncements = (
  variables: PostAnnouncementsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.AnnouncementResponse,
    PostAnnouncementsError,
    Schemas.AnnouncementRequest,
    {},
    {},
    {}
  >({ url: "/announcements", method: "post", ...variables, signal });

export const usePostAnnouncements = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AnnouncementResponse,
      PostAnnouncementsError,
      PostAnnouncementsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.AnnouncementResponse,
    PostAnnouncementsError,
    PostAnnouncementsVariables
  >({
    mutationFn: (variables: PostAnnouncementsVariables) =>
      fetchPostAnnouncements({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetAnnouncementsIdPathParams = {
  id: number;
};

export type GetAnnouncementsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetAnnouncementsIdVariables = {
  pathParams: GetAnnouncementsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetAnnouncementsId = (
  variables: GetAnnouncementsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.AnnouncementResponse,
    GetAnnouncementsIdError,
    undefined,
    {},
    {},
    GetAnnouncementsIdPathParams
  >({ url: "/announcements/{id}", method: "get", ...variables, signal });

export const useGetAnnouncementsId = <TData = Schemas.AnnouncementResponse>(
  variables: GetAnnouncementsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AnnouncementResponse,
      GetAnnouncementsIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.AnnouncementResponse,
    GetAnnouncementsIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/announcements/{id}",
      operationId: "getAnnouncementsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAnnouncementsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutAnnouncementsIdPathParams = {
  id: number;
};

export type PutAnnouncementsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutAnnouncementsIdVariables = {
  body: Schemas.AnnouncementRequest;
  pathParams: PutAnnouncementsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutAnnouncementsId = (
  variables: PutAnnouncementsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.AnnouncementResponse,
    PutAnnouncementsIdError,
    Schemas.AnnouncementRequest,
    {},
    {},
    PutAnnouncementsIdPathParams
  >({ url: "/announcements/{id}", method: "put", ...variables, signal });

export const usePutAnnouncementsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AnnouncementResponse,
      PutAnnouncementsIdError,
      PutAnnouncementsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.AnnouncementResponse,
    PutAnnouncementsIdError,
    PutAnnouncementsIdVariables
  >({
    mutationFn: (variables: PutAnnouncementsIdVariables) =>
      fetchPutAnnouncementsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteAnnouncementsIdPathParams = {
  id: number;
};

export type DeleteAnnouncementsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteAnnouncementsIdVariables = {
  pathParams: DeleteAnnouncementsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteAnnouncementsId = (
  variables: DeleteAnnouncementsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteAnnouncementsIdError,
    undefined,
    {},
    {},
    DeleteAnnouncementsIdPathParams
  >({ url: "/announcements/{id}", method: "delete", ...variables, signal });

export const useDeleteAnnouncementsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteAnnouncementsIdError,
      DeleteAnnouncementsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteAnnouncementsIdError,
    DeleteAnnouncementsIdVariables
  >({
    mutationFn: (variables: DeleteAnnouncementsIdVariables) =>
      fetchDeleteAnnouncementsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostAnnouncementsIdLocalizationsPathParams = {
  id: number;
};

export type PostAnnouncementsIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostAnnouncementsIdLocalizationsVariables = {
  body: Schemas.AnnouncementLocalizationRequest;
  pathParams: PostAnnouncementsIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostAnnouncementsIdLocalizations = (
  variables: PostAnnouncementsIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.AnnouncementLocalizationResponse,
    PostAnnouncementsIdLocalizationsError,
    Schemas.AnnouncementLocalizationRequest,
    {},
    {},
    PostAnnouncementsIdLocalizationsPathParams
  >({
    url: "/announcements/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAnnouncementsIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AnnouncementLocalizationResponse,
      PostAnnouncementsIdLocalizationsError,
      PostAnnouncementsIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.AnnouncementLocalizationResponse,
    PostAnnouncementsIdLocalizationsError,
    PostAnnouncementsIdLocalizationsVariables
  >({
    mutationFn: (variables: PostAnnouncementsIdLocalizationsVariables) =>
      fetchPostAnnouncementsIdLocalizations({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetBannersQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetBannersError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetBannersVariables = {
  queryParams?: GetBannersQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetBanners = (
  variables: GetBannersVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.BannerListResponse,
    GetBannersError,
    undefined,
    {},
    GetBannersQueryParams,
    {}
  >({ url: "/banners", method: "get", ...variables, signal });

export const useGetBanners = <TData = Schemas.BannerListResponse>(
  variables: GetBannersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BannerListResponse,
      GetBannersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.BannerListResponse,
    GetBannersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/banners",
      operationId: "getBanners",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBanners({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostBannersError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostBannersVariables = {
  body: Schemas.BannerRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostBanners = (
  variables: PostBannersVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.BannerResponse,
    PostBannersError,
    Schemas.BannerRequest,
    {},
    {},
    {}
  >({ url: "/banners", method: "post", ...variables, signal });

export const usePostBanners = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BannerResponse,
      PostBannersError,
      PostBannersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BannerResponse,
    PostBannersError,
    PostBannersVariables
  >({
    mutationFn: (variables: PostBannersVariables) =>
      fetchPostBanners({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetBannersIdPathParams = {
  id: number;
};

export type GetBannersIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetBannersIdVariables = {
  pathParams: GetBannersIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetBannersId = (
  variables: GetBannersIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.BannerResponse,
    GetBannersIdError,
    undefined,
    {},
    {},
    GetBannersIdPathParams
  >({ url: "/banners/{id}", method: "get", ...variables, signal });

export const useGetBannersId = <TData = Schemas.BannerResponse>(
  variables: GetBannersIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BannerResponse,
      GetBannersIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.BannerResponse, GetBannersIdError, TData>({
    queryKey: queryKeyFn({
      path: "/banners/{id}",
      operationId: "getBannersId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetBannersId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutBannersIdPathParams = {
  id: number;
};

export type PutBannersIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutBannersIdVariables = {
  body: Schemas.BannerRequest;
  pathParams: PutBannersIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutBannersId = (
  variables: PutBannersIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.BannerResponse,
    PutBannersIdError,
    Schemas.BannerRequest,
    {},
    {},
    PutBannersIdPathParams
  >({ url: "/banners/{id}", method: "put", ...variables, signal });

export const usePutBannersId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BannerResponse,
      PutBannersIdError,
      PutBannersIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BannerResponse,
    PutBannersIdError,
    PutBannersIdVariables
  >({
    mutationFn: (variables: PutBannersIdVariables) =>
      fetchPutBannersId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteBannersIdPathParams = {
  id: number;
};

export type DeleteBannersIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteBannersIdVariables = {
  pathParams: DeleteBannersIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteBannersId = (
  variables: DeleteBannersIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteBannersIdError,
    undefined,
    {},
    {},
    DeleteBannersIdPathParams
  >({ url: "/banners/{id}", method: "delete", ...variables, signal });

export const useDeleteBannersId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteBannersIdError,
      DeleteBannersIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteBannersIdError,
    DeleteBannersIdVariables
  >({
    mutationFn: (variables: DeleteBannersIdVariables) =>
      fetchDeleteBannersId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostBannersIdLocalizationsPathParams = {
  id: number;
};

export type PostBannersIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostBannersIdLocalizationsVariables = {
  body: Schemas.BannerLocalizationRequest;
  pathParams: PostBannersIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostBannersIdLocalizations = (
  variables: PostBannersIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.BannerLocalizationResponse,
    PostBannersIdLocalizationsError,
    Schemas.BannerLocalizationRequest,
    {},
    {},
    PostBannersIdLocalizationsPathParams
  >({
    url: "/banners/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostBannersIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BannerLocalizationResponse,
      PostBannersIdLocalizationsError,
      PostBannersIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BannerLocalizationResponse,
    PostBannersIdLocalizationsError,
    PostBannersIdLocalizationsVariables
  >({
    mutationFn: (variables: PostBannersIdLocalizationsVariables) =>
      fetchPostBannersIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetChurchInfoQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetChurchInfoError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetChurchInfoVariables = {
  queryParams?: GetChurchInfoQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetChurchInfo = (
  variables: GetChurchInfoVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ChurchInfoResponse,
    GetChurchInfoError,
    undefined,
    {},
    GetChurchInfoQueryParams,
    {}
  >({ url: "/church-info", method: "get", ...variables, signal });

export const useGetChurchInfo = <TData = Schemas.ChurchInfoResponse>(
  variables: GetChurchInfoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChurchInfoResponse,
      GetChurchInfoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ChurchInfoResponse,
    GetChurchInfoError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/church-info",
      operationId: "getChurchInfo",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetChurchInfo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutChurchInfoError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutChurchInfoVariables = {
  body: Schemas.ChurchInfoRequest;
} & ApiContext["fetcherOptions"];

export const fetchPutChurchInfo = (
  variables: PutChurchInfoVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ChurchInfoResponse,
    PutChurchInfoError,
    Schemas.ChurchInfoRequest,
    {},
    {},
    {}
  >({ url: "/church-info", method: "put", ...variables, signal });

export const usePutChurchInfo = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ChurchInfoResponse,
      PutChurchInfoError,
      PutChurchInfoVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ChurchInfoResponse,
    PutChurchInfoError,
    PutChurchInfoVariables
  >({
    mutationFn: (variables: PutChurchInfoVariables) =>
      fetchPutChurchInfo({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteChurchInfoError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteChurchInfoVariables = ApiContext["fetcherOptions"];

export const fetchDeleteChurchInfo = (
  variables: DeleteChurchInfoVariables,
  signal?: AbortSignal,
) =>
  apiFetch<number, DeleteChurchInfoError, undefined, {}, {}, {}>({
    url: "/church-info",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteChurchInfo = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteChurchInfoError,
      DeleteChurchInfoVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteChurchInfoError,
    DeleteChurchInfoVariables
  >({
    mutationFn: (variables: DeleteChurchInfoVariables) =>
      fetchDeleteChurchInfo({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostChurchInfoLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostChurchInfoLocalizationsVariables = {
  body: Schemas.ChurchInfoLocalizationRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostChurchInfoLocalizations = (
  variables: PostChurchInfoLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ChurchInfoLocalizationResponse,
    PostChurchInfoLocalizationsError,
    Schemas.ChurchInfoLocalizationRequest,
    {},
    {},
    {}
  >({
    url: "/church-info/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostChurchInfoLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ChurchInfoLocalizationResponse,
      PostChurchInfoLocalizationsError,
      PostChurchInfoLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ChurchInfoLocalizationResponse,
    PostChurchInfoLocalizationsError,
    PostChurchInfoLocalizationsVariables
  >({
    mutationFn: (variables: PostChurchInfoLocalizationsVariables) =>
      fetchPostChurchInfoLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetEventsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetEventsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetEventsVariables = {
  queryParams?: GetEventsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetEvents = (
  variables: GetEventsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.EventListResponse,
    GetEventsError,
    undefined,
    {},
    GetEventsQueryParams,
    {}
  >({ url: "/events", method: "get", ...variables, signal });

export const useGetEvents = <TData = Schemas.EventListResponse>(
  variables: GetEventsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventListResponse,
      GetEventsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.EventListResponse, GetEventsError, TData>({
    queryKey: queryKeyFn({
      path: "/events",
      operationId: "getEvents",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetEvents({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostEventsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostEventsVariables = {
  body: Schemas.EventRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostEvents = (
  variables: PostEventsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.EventResponse,
    PostEventsError,
    Schemas.EventRequest,
    {},
    {},
    {}
  >({ url: "/events", method: "post", ...variables, signal });

export const usePostEvents = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventResponse,
      PostEventsError,
      PostEventsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.EventResponse,
    PostEventsError,
    PostEventsVariables
  >({
    mutationFn: (variables: PostEventsVariables) =>
      fetchPostEvents({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetEventsIdPathParams = {
  id: number;
};

export type GetEventsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetEventsIdVariables = {
  pathParams: GetEventsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetEventsId = (
  variables: GetEventsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.EventResponse,
    GetEventsIdError,
    undefined,
    {},
    {},
    GetEventsIdPathParams
  >({ url: "/events/{id}", method: "get", ...variables, signal });

export const useGetEventsId = <TData = Schemas.EventResponse>(
  variables: GetEventsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.EventResponse, GetEventsIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.EventResponse, GetEventsIdError, TData>({
    queryKey: queryKeyFn({
      path: "/events/{id}",
      operationId: "getEventsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetEventsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutEventsIdPathParams = {
  id: number;
};

export type PutEventsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutEventsIdVariables = {
  body: Schemas.EventRequest;
  pathParams: PutEventsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutEventsId = (
  variables: PutEventsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.EventResponse,
    PutEventsIdError,
    Schemas.EventRequest,
    {},
    {},
    PutEventsIdPathParams
  >({ url: "/events/{id}", method: "put", ...variables, signal });

export const usePutEventsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventResponse,
      PutEventsIdError,
      PutEventsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.EventResponse,
    PutEventsIdError,
    PutEventsIdVariables
  >({
    mutationFn: (variables: PutEventsIdVariables) =>
      fetchPutEventsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteEventsIdPathParams = {
  id: number;
};

export type DeleteEventsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteEventsIdVariables = {
  pathParams: DeleteEventsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteEventsId = (
  variables: DeleteEventsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteEventsIdError,
    undefined,
    {},
    {},
    DeleteEventsIdPathParams
  >({ url: "/events/{id}", method: "delete", ...variables, signal });

export const useDeleteEventsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteEventsIdError,
      DeleteEventsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteEventsIdError,
    DeleteEventsIdVariables
  >({
    mutationFn: (variables: DeleteEventsIdVariables) =>
      fetchDeleteEventsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostEventsIdLocalizationsPathParams = {
  id: number;
};

export type PostEventsIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostEventsIdLocalizationsVariables = {
  body: Schemas.EventLocalizationRequest;
  pathParams: PostEventsIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostEventsIdLocalizations = (
  variables: PostEventsIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.EventLocalizationResponse,
    PostEventsIdLocalizationsError,
    Schemas.EventLocalizationRequest,
    {},
    {},
    PostEventsIdLocalizationsPathParams
  >({
    url: "/events/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostEventsIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventLocalizationResponse,
      PostEventsIdLocalizationsError,
      PostEventsIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.EventLocalizationResponse,
    PostEventsIdLocalizationsError,
    PostEventsIdLocalizationsVariables
  >({
    mutationFn: (variables: PostEventsIdLocalizationsVariables) =>
      fetchPostEventsIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetGroupsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetGroupsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetGroupsVariables = {
  queryParams?: GetGroupsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetGroups = (
  variables: GetGroupsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GroupListResponse,
    GetGroupsError,
    undefined,
    {},
    GetGroupsQueryParams,
    {}
  >({ url: "/groups", method: "get", ...variables, signal });

export const useGetGroups = <TData = Schemas.GroupListResponse>(
  variables: GetGroupsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GroupListResponse,
      GetGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.GroupListResponse, GetGroupsError, TData>({
    queryKey: queryKeyFn({
      path: "/groups",
      operationId: "getGroups",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetGroups({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostGroupsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostGroupsVariables = {
  body: Schemas.GroupRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostGroups = (
  variables: PostGroupsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GroupResponse,
    PostGroupsError,
    Schemas.GroupRequest,
    {},
    {},
    {}
  >({ url: "/groups", method: "post", ...variables, signal });

export const usePostGroups = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.GroupResponse,
      PostGroupsError,
      PostGroupsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.GroupResponse,
    PostGroupsError,
    PostGroupsVariables
  >({
    mutationFn: (variables: PostGroupsVariables) =>
      fetchPostGroups({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetGroupsIdPathParams = {
  id: number;
};

export type GetGroupsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetGroupsIdVariables = {
  pathParams: GetGroupsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetGroupsId = (
  variables: GetGroupsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GroupResponse,
    GetGroupsIdError,
    undefined,
    {},
    {},
    GetGroupsIdPathParams
  >({ url: "/groups/{id}", method: "get", ...variables, signal });

export const useGetGroupsId = <TData = Schemas.GroupResponse>(
  variables: GetGroupsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.GroupResponse, GetGroupsIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.GroupResponse, GetGroupsIdError, TData>({
    queryKey: queryKeyFn({
      path: "/groups/{id}",
      operationId: "getGroupsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetGroupsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutGroupsIdPathParams = {
  id: number;
};

export type PutGroupsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutGroupsIdVariables = {
  body: Schemas.GroupRequest;
  pathParams: PutGroupsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutGroupsId = (
  variables: PutGroupsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GroupResponse,
    PutGroupsIdError,
    Schemas.GroupRequest,
    {},
    {},
    PutGroupsIdPathParams
  >({ url: "/groups/{id}", method: "put", ...variables, signal });

export const usePutGroupsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.GroupResponse,
      PutGroupsIdError,
      PutGroupsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.GroupResponse,
    PutGroupsIdError,
    PutGroupsIdVariables
  >({
    mutationFn: (variables: PutGroupsIdVariables) =>
      fetchPutGroupsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteGroupsIdPathParams = {
  id: number;
};

export type DeleteGroupsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteGroupsIdVariables = {
  pathParams: DeleteGroupsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteGroupsId = (
  variables: DeleteGroupsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteGroupsIdError,
    undefined,
    {},
    {},
    DeleteGroupsIdPathParams
  >({ url: "/groups/{id}", method: "delete", ...variables, signal });

export const useDeleteGroupsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteGroupsIdError,
      DeleteGroupsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteGroupsIdError,
    DeleteGroupsIdVariables
  >({
    mutationFn: (variables: DeleteGroupsIdVariables) =>
      fetchDeleteGroupsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostGroupsIdLocalizationsPathParams = {
  id: number;
};

export type PostGroupsIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostGroupsIdLocalizationsVariables = {
  body: Schemas.GroupLocalizationRequest;
  pathParams: PostGroupsIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostGroupsIdLocalizations = (
  variables: PostGroupsIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GroupLocalizationResponse,
    PostGroupsIdLocalizationsError,
    Schemas.GroupLocalizationRequest,
    {},
    {},
    PostGroupsIdLocalizationsPathParams
  >({
    url: "/groups/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostGroupsIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.GroupLocalizationResponse,
      PostGroupsIdLocalizationsError,
      PostGroupsIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.GroupLocalizationResponse,
    PostGroupsIdLocalizationsError,
    PostGroupsIdLocalizationsVariables
  >({
    mutationFn: (variables: PostGroupsIdLocalizationsVariables) =>
      fetchPostGroupsIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetLeadersQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetLeadersError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetLeadersVariables = {
  queryParams?: GetLeadersQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetLeaders = (
  variables: GetLeadersVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.LeaderListResponse,
    GetLeadersError,
    undefined,
    {},
    GetLeadersQueryParams,
    {}
  >({ url: "/leaders", method: "get", ...variables, signal });

export const useGetLeaders = <TData = Schemas.LeaderListResponse>(
  variables: GetLeadersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LeaderListResponse,
      GetLeadersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.LeaderListResponse,
    GetLeadersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/leaders",
      operationId: "getLeaders",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLeaders({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostLeadersError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostLeadersVariables = {
  body: Schemas.LeaderRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostLeaders = (
  variables: PostLeadersVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.LeaderResponse,
    PostLeadersError,
    Schemas.LeaderRequest,
    {},
    {},
    {}
  >({ url: "/leaders", method: "post", ...variables, signal });

export const usePostLeaders = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LeaderResponse,
      PostLeadersError,
      PostLeadersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LeaderResponse,
    PostLeadersError,
    PostLeadersVariables
  >({
    mutationFn: (variables: PostLeadersVariables) =>
      fetchPostLeaders({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetLeadersIdPathParams = {
  id: number;
};

export type GetLeadersIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetLeadersIdVariables = {
  pathParams: GetLeadersIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetLeadersId = (
  variables: GetLeadersIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.LeaderResponse,
    GetLeadersIdError,
    undefined,
    {},
    {},
    GetLeadersIdPathParams
  >({ url: "/leaders/{id}", method: "get", ...variables, signal });

export const useGetLeadersId = <TData = Schemas.LeaderResponse>(
  variables: GetLeadersIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LeaderResponse,
      GetLeadersIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.LeaderResponse, GetLeadersIdError, TData>({
    queryKey: queryKeyFn({
      path: "/leaders/{id}",
      operationId: "getLeadersId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLeadersId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutLeadersIdPathParams = {
  id: number;
};

export type PutLeadersIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutLeadersIdVariables = {
  body: Schemas.LeaderRequest;
  pathParams: PutLeadersIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutLeadersId = (
  variables: PutLeadersIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.LeaderResponse,
    PutLeadersIdError,
    Schemas.LeaderRequest,
    {},
    {},
    PutLeadersIdPathParams
  >({ url: "/leaders/{id}", method: "put", ...variables, signal });

export const usePutLeadersId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LeaderResponse,
      PutLeadersIdError,
      PutLeadersIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LeaderResponse,
    PutLeadersIdError,
    PutLeadersIdVariables
  >({
    mutationFn: (variables: PutLeadersIdVariables) =>
      fetchPutLeadersId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteLeadersIdPathParams = {
  id: number;
};

export type DeleteLeadersIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteLeadersIdVariables = {
  pathParams: DeleteLeadersIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteLeadersId = (
  variables: DeleteLeadersIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteLeadersIdError,
    undefined,
    {},
    {},
    DeleteLeadersIdPathParams
  >({ url: "/leaders/{id}", method: "delete", ...variables, signal });

export const useDeleteLeadersId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteLeadersIdError,
      DeleteLeadersIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteLeadersIdError,
    DeleteLeadersIdVariables
  >({
    mutationFn: (variables: DeleteLeadersIdVariables) =>
      fetchDeleteLeadersId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostLeadersIdLocalizationsPathParams = {
  id: number;
};

export type PostLeadersIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostLeadersIdLocalizationsVariables = {
  body: Schemas.LeaderLocalizationRequest;
  pathParams: PostLeadersIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostLeadersIdLocalizations = (
  variables: PostLeadersIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.LeaderLocalizationResponse,
    PostLeadersIdLocalizationsError,
    Schemas.LeaderLocalizationRequest,
    {},
    {},
    PostLeadersIdLocalizationsPathParams
  >({
    url: "/leaders/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostLeadersIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LeaderLocalizationResponse,
      PostLeadersIdLocalizationsError,
      PostLeadersIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LeaderLocalizationResponse,
    PostLeadersIdLocalizationsError,
    PostLeadersIdLocalizationsVariables
  >({
    mutationFn: (variables: PostLeadersIdLocalizationsVariables) =>
      fetchPostLeadersIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetServicesQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetServicesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetServicesVariables = {
  queryParams?: GetServicesQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetServices = (
  variables: GetServicesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ServiceListResponse,
    GetServicesError,
    undefined,
    {},
    GetServicesQueryParams,
    {}
  >({ url: "/services", method: "get", ...variables, signal });

export const useGetServices = <TData = Schemas.ServiceListResponse>(
  variables: GetServicesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ServiceListResponse,
      GetServicesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ServiceListResponse,
    GetServicesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/services",
      operationId: "getServices",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetServices({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostServicesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostServicesVariables = {
  body: Schemas.ServiceRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostServices = (
  variables: PostServicesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ServiceResponse,
    PostServicesError,
    Schemas.ServiceRequest,
    {},
    {},
    {}
  >({ url: "/services", method: "post", ...variables, signal });

export const usePostServices = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ServiceResponse,
      PostServicesError,
      PostServicesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ServiceResponse,
    PostServicesError,
    PostServicesVariables
  >({
    mutationFn: (variables: PostServicesVariables) =>
      fetchPostServices({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetServicesIdPathParams = {
  id: number;
};

export type GetServicesIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetServicesIdVariables = {
  pathParams: GetServicesIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetServicesId = (
  variables: GetServicesIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ServiceResponse,
    GetServicesIdError,
    undefined,
    {},
    {},
    GetServicesIdPathParams
  >({ url: "/services/{id}", method: "get", ...variables, signal });

export const useGetServicesId = <TData = Schemas.ServiceResponse>(
  variables: GetServicesIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ServiceResponse,
      GetServicesIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ServiceResponse,
    GetServicesIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/services/{id}",
      operationId: "getServicesId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetServicesId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutServicesIdPathParams = {
  id: number;
};

export type PutServicesIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutServicesIdVariables = {
  body: Schemas.ServiceRequest;
  pathParams: PutServicesIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutServicesId = (
  variables: PutServicesIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ServiceResponse,
    PutServicesIdError,
    Schemas.ServiceRequest,
    {},
    {},
    PutServicesIdPathParams
  >({ url: "/services/{id}", method: "put", ...variables, signal });

export const usePutServicesId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ServiceResponse,
      PutServicesIdError,
      PutServicesIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ServiceResponse,
    PutServicesIdError,
    PutServicesIdVariables
  >({
    mutationFn: (variables: PutServicesIdVariables) =>
      fetchPutServicesId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteServicesIdPathParams = {
  id: number;
};

export type DeleteServicesIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteServicesIdVariables = {
  pathParams: DeleteServicesIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteServicesId = (
  variables: DeleteServicesIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteServicesIdError,
    undefined,
    {},
    {},
    DeleteServicesIdPathParams
  >({ url: "/services/{id}", method: "delete", ...variables, signal });

export const useDeleteServicesId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteServicesIdError,
      DeleteServicesIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteServicesIdError,
    DeleteServicesIdVariables
  >({
    mutationFn: (variables: DeleteServicesIdVariables) =>
      fetchDeleteServicesId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostServicesIdLocalizationsPathParams = {
  id: number;
};

export type PostServicesIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostServicesIdLocalizationsVariables = {
  body: Schemas.ServiceLocalizationRequest;
  pathParams: PostServicesIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostServicesIdLocalizations = (
  variables: PostServicesIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ServiceLocalizationResponse,
    PostServicesIdLocalizationsError,
    Schemas.ServiceLocalizationRequest,
    {},
    {},
    PostServicesIdLocalizationsPathParams
  >({
    url: "/services/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostServicesIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ServiceLocalizationResponse,
      PostServicesIdLocalizationsError,
      PostServicesIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ServiceLocalizationResponse,
    PostServicesIdLocalizationsError,
    PostServicesIdLocalizationsVariables
  >({
    mutationFn: (variables: PostServicesIdLocalizationsVariables) =>
      fetchPostServicesIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetSupportsQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetSupportsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetSupportsVariables = {
  queryParams?: GetSupportsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetSupports = (
  variables: GetSupportsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SupportListResponse,
    GetSupportsError,
    undefined,
    {},
    GetSupportsQueryParams,
    {}
  >({ url: "/supports", method: "get", ...variables, signal });

export const useGetSupports = <TData = Schemas.SupportListResponse>(
  variables: GetSupportsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SupportListResponse,
      GetSupportsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SupportListResponse,
    GetSupportsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/supports",
      operationId: "getSupports",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetSupports({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostSupportsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostSupportsVariables = {
  body: Schemas.SupportRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostSupports = (
  variables: PostSupportsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SupportResponse,
    PostSupportsError,
    Schemas.SupportRequest,
    {},
    {},
    {}
  >({ url: "/supports", method: "post", ...variables, signal });

export const usePostSupports = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SupportResponse,
      PostSupportsError,
      PostSupportsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.SupportResponse,
    PostSupportsError,
    PostSupportsVariables
  >({
    mutationFn: (variables: PostSupportsVariables) =>
      fetchPostSupports({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetSupportsIdPathParams = {
  id: number;
};

export type GetSupportsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetSupportsIdVariables = {
  pathParams: GetSupportsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetSupportsId = (
  variables: GetSupportsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SupportResponse,
    GetSupportsIdError,
    undefined,
    {},
    {},
    GetSupportsIdPathParams
  >({ url: "/supports/{id}", method: "get", ...variables, signal });

export const useGetSupportsId = <TData = Schemas.SupportResponse>(
  variables: GetSupportsIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SupportResponse,
      GetSupportsIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SupportResponse,
    GetSupportsIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/supports/{id}",
      operationId: "getSupportsId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetSupportsId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutSupportsIdPathParams = {
  id: number;
};

export type PutSupportsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutSupportsIdVariables = {
  body: Schemas.SupportRequest;
  pathParams: PutSupportsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutSupportsId = (
  variables: PutSupportsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SupportResponse,
    PutSupportsIdError,
    Schemas.SupportRequest,
    {},
    {},
    PutSupportsIdPathParams
  >({ url: "/supports/{id}", method: "put", ...variables, signal });

export const usePutSupportsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SupportResponse,
      PutSupportsIdError,
      PutSupportsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.SupportResponse,
    PutSupportsIdError,
    PutSupportsIdVariables
  >({
    mutationFn: (variables: PutSupportsIdVariables) =>
      fetchPutSupportsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteSupportsIdPathParams = {
  id: number;
};

export type DeleteSupportsIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteSupportsIdVariables = {
  pathParams: DeleteSupportsIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteSupportsId = (
  variables: DeleteSupportsIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteSupportsIdError,
    undefined,
    {},
    {},
    DeleteSupportsIdPathParams
  >({ url: "/supports/{id}", method: "delete", ...variables, signal });

export const useDeleteSupportsId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteSupportsIdError,
      DeleteSupportsIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteSupportsIdError,
    DeleteSupportsIdVariables
  >({
    mutationFn: (variables: DeleteSupportsIdVariables) =>
      fetchDeleteSupportsId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostSupportsIdLocalizationsPathParams = {
  id: number;
};

export type PostSupportsIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostSupportsIdLocalizationsVariables = {
  body: Schemas.SupportLocalizationRequest;
  pathParams: PostSupportsIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostSupportsIdLocalizations = (
  variables: PostSupportsIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SupportLocalizationResponse,
    PostSupportsIdLocalizationsError,
    Schemas.SupportLocalizationRequest,
    {},
    {},
    PostSupportsIdLocalizationsPathParams
  >({
    url: "/supports/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostSupportsIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SupportLocalizationResponse,
      PostSupportsIdLocalizationsError,
      PostSupportsIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.SupportLocalizationResponse,
    PostSupportsIdLocalizationsError,
    PostSupportsIdLocalizationsVariables
  >({
    mutationFn: (variables: PostSupportsIdLocalizationsVariables) =>
      fetchPostSupportsIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserInfosQueryParams = {
  /**
   * Sort by attributes ascending (asc) or descending (desc)
   */
  sort?: string;
  /**
   * Return page/pageSize (default: true)
   */
  ["pagination[withCount]"]?: boolean;
  /**
   * Page number (default: 0)
   */
  ["pagination[page]"]?: number;
  /**
   * Page size (default: 25)
   */
  ["pagination[pageSize]"]?: number;
  /**
   * Offset value (default: 0)
   */
  ["pagination[start]"]?: number;
  /**
   * Number of entities to return (default: 25)
   */
  ["pagination[limit]"]?: number;
  /**
   * Fields to return (ex: title,author)
   */
  fields?: string;
  /**
   * Relations to return
   */
  populate?: string;
  /**
   * Filters to apply
   */
  filters?: Record<string, any>;
  /**
   * Locale to apply
   */
  locale?: string;
};

export type GetUserInfosError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetUserInfosVariables = {
  queryParams?: GetUserInfosQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetUserInfos = (
  variables: GetUserInfosVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserInfoListResponse,
    GetUserInfosError,
    undefined,
    {},
    GetUserInfosQueryParams,
    {}
  >({ url: "/user-infos", method: "get", ...variables, signal });

export const useGetUserInfos = <TData = Schemas.UserInfoListResponse>(
  variables: GetUserInfosVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserInfoListResponse,
      GetUserInfosError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserInfoListResponse,
    GetUserInfosError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/user-infos",
      operationId: "getUserInfos",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserInfos({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostUserInfosError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostUserInfosVariables = {
  body: Schemas.UserInfoRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostUserInfos = (
  variables: PostUserInfosVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserInfoResponse,
    PostUserInfosError,
    Schemas.UserInfoRequest,
    {},
    {},
    {}
  >({ url: "/user-infos", method: "post", ...variables, signal });

export const usePostUserInfos = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserInfoResponse,
      PostUserInfosError,
      PostUserInfosVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UserInfoResponse,
    PostUserInfosError,
    PostUserInfosVariables
  >({
    mutationFn: (variables: PostUserInfosVariables) =>
      fetchPostUserInfos({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetUserInfosIdPathParams = {
  id: number;
};

export type GetUserInfosIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type GetUserInfosIdVariables = {
  pathParams: GetUserInfosIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetUserInfosId = (
  variables: GetUserInfosIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserInfoResponse,
    GetUserInfosIdError,
    undefined,
    {},
    {},
    GetUserInfosIdPathParams
  >({ url: "/user-infos/{id}", method: "get", ...variables, signal });

export const useGetUserInfosId = <TData = Schemas.UserInfoResponse>(
  variables: GetUserInfosIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserInfoResponse,
      GetUserInfosIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserInfoResponse,
    GetUserInfosIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/user-infos/{id}",
      operationId: "getUserInfosId",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetUserInfosId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PutUserInfosIdPathParams = {
  id: number;
};

export type PutUserInfosIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PutUserInfosIdVariables = {
  body: Schemas.UserInfoRequest;
  pathParams: PutUserInfosIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutUserInfosId = (
  variables: PutUserInfosIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserInfoResponse,
    PutUserInfosIdError,
    Schemas.UserInfoRequest,
    {},
    {},
    PutUserInfosIdPathParams
  >({ url: "/user-infos/{id}", method: "put", ...variables, signal });

export const usePutUserInfosId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserInfoResponse,
      PutUserInfosIdError,
      PutUserInfosIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UserInfoResponse,
    PutUserInfosIdError,
    PutUserInfosIdVariables
  >({
    mutationFn: (variables: PutUserInfosIdVariables) =>
      fetchPutUserInfosId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteUserInfosIdPathParams = {
  id: number;
};

export type DeleteUserInfosIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type DeleteUserInfosIdVariables = {
  pathParams: DeleteUserInfosIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteUserInfosId = (
  variables: DeleteUserInfosIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    number,
    DeleteUserInfosIdError,
    undefined,
    {},
    {},
    DeleteUserInfosIdPathParams
  >({ url: "/user-infos/{id}", method: "delete", ...variables, signal });

export const useDeleteUserInfosId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      DeleteUserInfosIdError,
      DeleteUserInfosIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    number,
    DeleteUserInfosIdError,
    DeleteUserInfosIdVariables
  >({
    mutationFn: (variables: DeleteUserInfosIdVariables) =>
      fetchDeleteUserInfosId({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUserInfosIdLocalizationsPathParams = {
  id: number;
};

export type PostUserInfosIdLocalizationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.Error;
    }
  | {
      status: 401;
      payload: Schemas.Error;
    }
  | {
      status: 403;
      payload: Schemas.Error;
    }
  | {
      status: 404;
      payload: Schemas.Error;
    }
  | {
      status: 500;
      payload: Schemas.Error;
    }
>;

export type PostUserInfosIdLocalizationsVariables = {
  body: Schemas.UserInfoLocalizationRequest;
  pathParams: PostUserInfosIdLocalizationsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPostUserInfosIdLocalizations = (
  variables: PostUserInfosIdLocalizationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserInfoLocalizationResponse,
    PostUserInfosIdLocalizationsError,
    Schemas.UserInfoLocalizationRequest,
    {},
    {},
    PostUserInfosIdLocalizationsPathParams
  >({
    url: "/user-infos/{id}/localizations",
    method: "post",
    ...variables,
    signal,
  });

export const usePostUserInfosIdLocalizations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserInfoLocalizationResponse,
      PostUserInfosIdLocalizationsError,
      PostUserInfosIdLocalizationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UserInfoLocalizationResponse,
    PostUserInfosIdLocalizationsError,
    PostUserInfosIdLocalizationsVariables
  >({
    mutationFn: (variables: PostUserInfosIdLocalizationsVariables) =>
      fetchPostUserInfosIdLocalizations({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/announcements";
      operationId: "getAnnouncements";
      variables: GetAnnouncementsVariables;
    }
  | {
      path: "/announcements/{id}";
      operationId: "getAnnouncementsId";
      variables: GetAnnouncementsIdVariables;
    }
  | {
      path: "/banners";
      operationId: "getBanners";
      variables: GetBannersVariables;
    }
  | {
      path: "/banners/{id}";
      operationId: "getBannersId";
      variables: GetBannersIdVariables;
    }
  | {
      path: "/church-info";
      operationId: "getChurchInfo";
      variables: GetChurchInfoVariables;
    }
  | {
      path: "/events";
      operationId: "getEvents";
      variables: GetEventsVariables;
    }
  | {
      path: "/events/{id}";
      operationId: "getEventsId";
      variables: GetEventsIdVariables;
    }
  | {
      path: "/groups";
      operationId: "getGroups";
      variables: GetGroupsVariables;
    }
  | {
      path: "/groups/{id}";
      operationId: "getGroupsId";
      variables: GetGroupsIdVariables;
    }
  | {
      path: "/leaders";
      operationId: "getLeaders";
      variables: GetLeadersVariables;
    }
  | {
      path: "/leaders/{id}";
      operationId: "getLeadersId";
      variables: GetLeadersIdVariables;
    }
  | {
      path: "/services";
      operationId: "getServices";
      variables: GetServicesVariables;
    }
  | {
      path: "/services/{id}";
      operationId: "getServicesId";
      variables: GetServicesIdVariables;
    }
  | {
      path: "/supports";
      operationId: "getSupports";
      variables: GetSupportsVariables;
    }
  | {
      path: "/supports/{id}";
      operationId: "getSupportsId";
      variables: GetSupportsIdVariables;
    }
  | {
      path: "/user-infos";
      operationId: "getUserInfos";
      variables: GetUserInfosVariables;
    }
  | {
      path: "/user-infos/{id}";
      operationId: "getUserInfosId";
      variables: GetUserInfosIdVariables;
    };
